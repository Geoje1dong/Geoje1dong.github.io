{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport clamp from 'lodash-es/clamp';\nimport debounce from 'lodash-es/debounce';\nimport { ScrollbarPlugin } from 'smooth-scrollbar';\nimport { Bounce } from './bounce';\nimport { Glow } from './glow';\nexport var OverscrollEffect;\n\n(function (OverscrollEffect) {\n  OverscrollEffect[\"BOUNCE\"] = \"bounce\";\n  OverscrollEffect[\"GLOW\"] = \"glow\";\n})(OverscrollEffect || (OverscrollEffect = {}));\n\nvar ALLOWED_EVENTS = /wheel|touch/;\n\nvar OverscrollPlugin =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(OverscrollPlugin, _super);\n\n  function OverscrollPlugin() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this._glow = new Glow(_this.scrollbar);\n    _this._bounce = new Bounce(_this.scrollbar);\n    _this._wheelScrollBack = {\n      x: false,\n      y: false\n    };\n    _this._lockWheel = {\n      x: false,\n      y: false\n    };\n    _this._touching = false;\n    _this._amplitude = {\n      x: 0,\n      y: 0\n    };\n    _this._position = {\n      x: 0,\n      y: 0\n    }; // since we can't detect whether user release touchpad\n    // handle it with debounce is the best solution now, as a trade-off\n\n    _this._releaseWheel = debounce(function () {\n      _this._lockWheel.x = false;\n      _this._lockWheel.y = false;\n    }, 30);\n    return _this;\n  }\n\n  Object.defineProperty(OverscrollPlugin.prototype, \"_isWheelLocked\", {\n    get: function () {\n      return this._lockWheel.x || this._lockWheel.y;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OverscrollPlugin.prototype, \"_enabled\", {\n    get: function () {\n      return !!this.options.effect;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  OverscrollPlugin.prototype.onInit = function () {\n    var _a = this,\n        _glow = _a._glow,\n        options = _a.options,\n        scrollbar = _a.scrollbar; // observe\n\n\n    var effect = options.effect;\n    Object.defineProperty(options, 'effect', {\n      get: function () {\n        return effect;\n      },\n      set: function (val) {\n        if (!val) {\n          effect = undefined;\n          return;\n        }\n\n        if (val !== OverscrollEffect.BOUNCE && val !== OverscrollEffect.GLOW) {\n          throw new TypeError(\"unknow overscroll effect: \" + val);\n        }\n\n        effect = val;\n        scrollbar.options.continuousScrolling = false;\n\n        if (val === OverscrollEffect.GLOW) {\n          _glow.mount();\n\n          _glow.adjust();\n        } else {\n          _glow.unmount();\n        }\n      }\n    });\n    options.effect = effect; // init\n  };\n\n  OverscrollPlugin.prototype.onUpdate = function () {\n    if (this.options.effect === OverscrollEffect.GLOW) {\n      this._glow.adjust();\n    }\n  };\n\n  OverscrollPlugin.prototype.onRender = function (remainMomentum) {\n    if (!this._enabled) {\n      return;\n    }\n\n    if (this.scrollbar.options.continuousScrolling) {\n      // turn off continuous scrolling\n      this.scrollbar.options.continuousScrolling = false;\n    }\n\n    var nextX = remainMomentum.x,\n        nextY = remainMomentum.y; // transfer remain momentum to overscroll\n\n    if (!this._amplitude.x && this._willOverscroll('x', remainMomentum.x)) {\n      nextX = 0;\n\n      this._absorbMomentum('x', remainMomentum.x);\n    }\n\n    if (!this._amplitude.y && this._willOverscroll('y', remainMomentum.y)) {\n      nextY = 0;\n\n      this._absorbMomentum('y', remainMomentum.y);\n    }\n\n    this.scrollbar.setMomentum(nextX, nextY);\n\n    this._render();\n  };\n\n  OverscrollPlugin.prototype.transformDelta = function (delta, fromEvent) {\n    this._lastEventType = fromEvent.type;\n\n    if (!this._enabled || !ALLOWED_EVENTS.test(fromEvent.type)) {\n      return delta;\n    }\n\n    if (this._isWheelLocked && /wheel/.test(fromEvent.type)) {\n      this._releaseWheel();\n\n      if (this._willOverscroll('x', delta.x)) {\n        delta.x = 0;\n      }\n\n      if (this._willOverscroll('y', delta.y)) {\n        delta.y = 0;\n      }\n    }\n\n    var nextX = delta.x,\n        nextY = delta.y;\n\n    if (this._willOverscroll('x', delta.x)) {\n      nextX = 0;\n\n      this._addAmplitude('x', delta.x);\n    }\n\n    if (this._willOverscroll('y', delta.y)) {\n      nextY = 0;\n\n      this._addAmplitude('y', delta.y);\n    }\n\n    switch (fromEvent.type) {\n      case 'touchstart':\n      case 'touchmove':\n        this._touching = true;\n\n        this._glow.recordTouch(fromEvent);\n\n        break;\n\n      case 'touchcancel':\n      case 'touchend':\n        this._touching = false;\n        break;\n    }\n\n    return {\n      x: nextX,\n      y: nextY\n    };\n  };\n\n  OverscrollPlugin.prototype._willOverscroll = function (direction, delta) {\n    if (!delta) {\n      return false;\n    } // away from origin\n\n\n    if (this._position[direction]) {\n      return true;\n    }\n\n    var offset = this.scrollbar.offset[direction];\n    var limit = this.scrollbar.limit[direction];\n\n    if (limit === 0) {\n      return false;\n    } // cond:\n    //  1. next scrolling position is supposed to stay unchange\n    //  2. current position is on the edge\n\n\n    return clamp(offset + delta, 0, limit) === offset && (offset === 0 || offset === limit);\n  };\n\n  OverscrollPlugin.prototype._absorbMomentum = function (direction, remainMomentum) {\n    var _a = this,\n        options = _a.options,\n        _lastEventType = _a._lastEventType,\n        _amplitude = _a._amplitude;\n\n    if (!ALLOWED_EVENTS.test(_lastEventType)) {\n      return;\n    }\n\n    _amplitude[direction] = clamp(remainMomentum, -options.maxOverscroll, options.maxOverscroll);\n  };\n\n  OverscrollPlugin.prototype._addAmplitude = function (direction, delta) {\n    var _a = this,\n        options = _a.options,\n        scrollbar = _a.scrollbar,\n        _amplitude = _a._amplitude,\n        _position = _a._position;\n\n    var currentAmp = _amplitude[direction];\n    var isOpposite = delta * currentAmp < 0;\n    var friction;\n\n    if (isOpposite) {\n      // opposite direction\n      friction = 0;\n    } else {\n      friction = this._wheelScrollBack[direction] ? 1 : Math.abs(currentAmp / options.maxOverscroll);\n    }\n\n    var amp = currentAmp + delta * (1 - friction);\n    _amplitude[direction] = scrollbar.offset[direction] === 0 ?\n    /*    top | left  */\n    clamp(amp, -options.maxOverscroll, 0) :\n    /* bottom | right */\n    clamp(amp, 0, options.maxOverscroll);\n\n    if (isOpposite) {\n      // scroll back\n      _position[direction] = _amplitude[direction];\n    }\n  };\n\n  OverscrollPlugin.prototype._render = function () {\n    var _a = this,\n        options = _a.options,\n        _amplitude = _a._amplitude,\n        _position = _a._position;\n\n    if (this._enabled && (_amplitude.x || _amplitude.y || _position.x || _position.y)) {\n      var nextX = this._nextAmp('x');\n\n      var nextY = this._nextAmp('y');\n\n      _amplitude.x = nextX.amplitude;\n      _position.x = nextX.position;\n      _amplitude.y = nextY.amplitude;\n      _position.y = nextY.position;\n\n      switch (options.effect) {\n        case OverscrollEffect.BOUNCE:\n          this._bounce.render(_position);\n\n          break;\n\n        case OverscrollEffect.GLOW:\n          this._glow.render(_position, this.options.glowColor);\n\n          break;\n      }\n\n      if (typeof options.onScroll === 'function') {\n        options.onScroll.call(this, tslib_1.__assign({}, _position));\n      }\n    }\n  };\n\n  OverscrollPlugin.prototype._nextAmp = function (direction) {\n    var _a = this,\n        options = _a.options,\n        _amplitude = _a._amplitude,\n        _position = _a._position;\n\n    var t = 1 - options.damping;\n    var amp = _amplitude[direction];\n    var pos = _position[direction];\n    var nextAmp = this._touching ? amp : amp * t | 0;\n    var distance = nextAmp - pos;\n    var nextPos = pos + distance - (distance * t | 0);\n\n    if (!this._touching && Math.abs(nextPos) < Math.abs(pos)) {\n      this._wheelScrollBack[direction] = true;\n    }\n\n    if (this._wheelScrollBack[direction] && Math.abs(nextPos) <= 1) {\n      this._wheelScrollBack[direction] = false;\n      this._lockWheel[direction] = true;\n    }\n\n    return {\n      amplitude: nextAmp,\n      position: nextPos\n    };\n  };\n\n  OverscrollPlugin.pluginName = 'overscroll';\n  OverscrollPlugin.defaultOptions = {\n    effect: OverscrollEffect.BOUNCE,\n    onScroll: undefined,\n    damping: 0.2,\n    maxOverscroll: 150,\n    glowColor: '#87ceeb'\n  };\n  return OverscrollPlugin;\n}(ScrollbarPlugin);\n\nexport default OverscrollPlugin;","map":null,"metadata":{},"sourceType":"module"}